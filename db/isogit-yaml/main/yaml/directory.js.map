{"version":3,"file":"directory.js","sourceRoot":"","sources":["../../../../../src/db/isogit-yaml/main/yaml/directory.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from 'path';\nimport * as fs from 'fs-extra';\nimport { YAML_EXT, YAML } from './base';\nimport { default as YAMLWrapper } from './file';\n\n\ninterface YAMLDirectoryStoreableContents extends YAML {\n  meta: YAML\n}\n\n\nclass YAMLDirectoryWrapper extends YAMLWrapper<YAML> {\n  // TODO: Move directory-specific logic into a Manager subclass.\n\n  constructor(baseDir: string) { super(baseDir); }\n\n  private expandDirectoryPath(objID: string) {\n    return path.join(this.baseDir, objID);\n  }\n\n  public async exists(objID: string) {\n    const dirPath = this.expandDirectoryPath(objID);\n    if (await fs.pathExists(dirPath)) {\n      const stat = await fs.stat(dirPath);\n      if (!stat.isDirectory()) {\n        throw new Error(\"File is expected to be a directory\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public async isValidID(value: string) {\n    const metaFile = path.join(this.expandDirectoryPath(value), `meta${YAML_EXT}`);\n    let metaFileIsFile: boolean;\n    try {\n      metaFileIsFile = (await fs.stat(metaFile)).isFile();\n    } catch (e) {\n      return false;\n    }\n    if (!metaFileIsFile) {\n      return false;\n    }\n    return metaFileIsFile;\n  }\n\n  // TODO: Instead of metaFields argument, specify _meta in object structure.\n  public async read(objID: string, metaFields: string[]) {\n    const objAbsPath = this.expandDirectoryPath(objID);\n\n    const metaId = 'meta';\n\n    const metaAbsPath = path.join(objAbsPath, `${metaId}${YAML_EXT}`);\n    let metaFileIsFile: boolean;\n    try {\n      metaFileIsFile = (await fs.stat(metaAbsPath)).isFile();\n    } catch (e) {\n      throw new Error(`Exception accessing meta file for ${objID}: ${metaAbsPath}: ${e.toString()} ${e.stack}`);\n    }\n    if (!metaFileIsFile) {\n      throw new Error(`Meta file for ${objID} is not a file: ${metaAbsPath}`);\n    }\n\n    var objData: YAML = {};\n\n    const metaPath = path.join(objID, metaId);\n    const meta = await super.read(metaPath) || {};\n    for (const key of metaFields) {\n      objData[key] = meta[key as string];\n    }\n\n    const dirContents = await fs.readdir(objAbsPath);\n    for (const filename of dirContents) {\n      if (this.isYAMLFile(filename)) {\n        const fieldName = path.basename(filename, YAML_EXT);\n        if (fieldName != 'meta') {\n          objData[fieldName] = await super.read(path.join(objID, fieldName));\n        }\n      }\n    }\n\n    // Blindly hope that data structure loaded from YAML\n    // is valid for given type.\n    return objData;\n  }\n\n  public async write<R extends YAML>(objID: string, newData?: R, metaFields?: (keyof R)[]) {\n    const objPath = this.expandDirectoryPath(objID);\n\n    if (newData !== undefined && metaFields !== undefined) {\n      await fs.ensureDir(objPath);\n\n      var dataToStore: YAMLDirectoryStoreableContents = { meta: {} };\n      var modifiedPaths = [] as string[];\n\n      for (const key of Object.keys(newData)) {\n        if (metaFields.indexOf(key) >= 0) {\n          dataToStore.meta[key] = newData[key];\n        } else {\n          dataToStore[key] = newData[key];\n        }\n      }\n\n      for (const [fieldName, fieldValue] of Object.entries(dataToStore)) {\n        modifiedPaths = [\n          ...modifiedPaths,\n          ...(await super.write(path.join(objID, fieldName), fieldValue)),\n        ];\n      }\n\n      return modifiedPaths;\n\n    } else if (newData !== undefined) {\n      throw new Error(\"metaFields is not specified\");\n\n    } else {\n      // Writing ``undefined`` should cause FS wrapper to delete the file from filesystem\n      await fs.remove(objPath);\n      return [objPath];\n    }\n  }\n}\n\nexport default YAMLDirectoryWrapper;\n"]}