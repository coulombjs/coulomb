import * as path from 'path';
import * as fs from 'fs-extra';
import * as yaml from 'js-yaml';
import { AbstractLockingFilesystemWrapper } from '../../../main/fs-wrapper';
import { Schema } from './schema';
const YAML_EXT = '.yaml';
export class YAMLWrapper extends AbstractLockingFilesystemWrapper {
    isYAMLFile(objID) {
        return path.extname(objID) === YAML_EXT;
    }
    async isValidID(objID) {
        return this.isYAMLFile(objID);
    }
    expandPath(objID) {
        // In this case, path to object should include YAML extension.
        return `${super.expandPath(objID)}${YAML_EXT}`;
    }
    parseData(data) {
        return yaml.load(data, { schema: Schema });
    }
    dumpData(data) {
        if (data !== undefined && data !== null) {
            return yaml.dump(data, {
                schema: Schema,
                noRefs: true,
                noCompatMode: true,
            });
        }
        else {
            throw new Error("Attempt to write invalid data (null or undefined)");
        }
    }
}
export class YAMLDirectoryWrapper extends YAMLWrapper {
    constructor(baseDir) { super(baseDir); }
    expandDirectoryPath(objID) {
        return path.join(this.baseDir, objID);
    }
    async exists(objID) {
        const dirPath = this.expandDirectoryPath(objID);
        if (await fs.pathExists(dirPath)) {
            const stat = await fs.stat(dirPath);
            if (!stat.isDirectory()) {
                throw new Error("File is expected to be a directory");
            }
            return true;
        }
        return false;
    }
    async isValidID(value) {
        const metaFile = path.join(this.expandDirectoryPath(value), `meta${YAML_EXT}`);
        let metaFileIsFile;
        try {
            metaFileIsFile = (await fs.stat(metaFile)).isFile();
        }
        catch (e) {
            return false;
        }
        if (!metaFileIsFile) {
            return false;
        }
        return metaFileIsFile;
    }
    async read(objID, metaFields) {
        const objAbsPath = this.expandDirectoryPath(objID);
        const metaId = 'meta';
        const metaAbsPath = path.join(objAbsPath, `${metaId}${YAML_EXT}`);
        let metaFileIsFile;
        try {
            metaFileIsFile = (await fs.stat(metaAbsPath)).isFile();
        }
        catch (e) {
            throw new Error(`Exception accessing meta file for ${objID}: ${metaAbsPath}: ${e.toString()} ${e.stack}`);
        }
        if (!metaFileIsFile) {
            throw new Error(`Meta file for ${objID} is not a file: ${metaAbsPath}`);
        }
        var objData = {};
        const metaPath = path.join(objID, metaId);
        const meta = await super.read(metaPath) || {};
        for (const key of metaFields) {
            objData[key] = meta[key];
        }
        const dirContents = await fs.readdir(objAbsPath);
        for (const filename of dirContents) {
            if (this.isYAMLFile(filename)) {
                const fieldName = path.basename(filename, YAML_EXT);
                if (fieldName != 'meta') {
                    objData[fieldName] = await super.read(path.join(objID, fieldName));
                }
            }
        }
        // Blindly hope that data structure loaded from YAML
        // is valid for given type.
        return objData;
    }
    async write(objID, newData, metaFields) {
        const objPath = this.expandDirectoryPath(objID);
        if (newData !== undefined && metaFields !== undefined) {
            await fs.ensureDir(objPath);
            var dataToStore = { meta: {} };
            var modifiedPaths = [];
            for (const key of Object.keys(newData)) {
                if (metaFields.indexOf(key) >= 0) {
                    dataToStore.meta[key] = newData[key];
                }
                else {
                    dataToStore[key] = newData[key];
                }
            }
            for (const [fieldName, fieldValue] of Object.entries(dataToStore)) {
                modifiedPaths = [
                    ...modifiedPaths,
                    ...(await super.write(path.join(objID, fieldName), fieldValue)),
                ];
            }
            return modifiedPaths;
        }
        else if (newData !== undefined) {
            throw new Error("metaFields is not specified");
        }
        else {
            // Writing ``undefined`` should cause FS wrapper to delete the file from filesystem
            return super.write(objID, newData);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZGIvaXNvZ2l0LXlhbWwvbWFpbi95YW1sL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sS0FBSyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sS0FBSyxJQUFJLE1BQU0sU0FBUyxDQUFDO0FBRWhDLE9BQU8sRUFBRSxnQ0FBZ0MsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRTVFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFHbEMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDO0FBYXpCLE1BQU0sT0FBTyxXQUFtQyxTQUFRLGdDQUFtQztJQUMvRSxVQUFVLENBQUMsS0FBYTtRQUNoQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxDQUFDO0lBQzFDLENBQUM7SUFFTSxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQWE7UUFDbEMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFTSxVQUFVLENBQUMsS0FBYTtRQUM3Qiw4REFBOEQ7UUFDOUQsT0FBTyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDakQsQ0FBQztJQUVTLFNBQVMsQ0FBQyxJQUFZO1FBQzlCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRVMsUUFBUSxDQUFDLElBQVM7UUFDMUIsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7WUFDdkMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtn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R0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUNoQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDdEM7cUJBQU07b0JBQ0wsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDakM7YUFDRjtZQUVELEtBQUssTUFBTSxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNqRSxhQUFhLEdBQUc7b0JBQ2QsR0FBRyxhQUFhO29CQUNoQixHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO2lCQUNoRSxDQUFDO2FBQ0g7WUFFRCxPQUFPLGFBQWEsQ0FBQztTQUV0QjthQUFNLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FFaEQ7YUFBTTtZQUNMLG1GQUFtRjtZQUNuRixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHlhbWwgZnJvbSAnanMteWFtbCc7XG5cbmltcG9ydCB7IEFic3RyYWN0TG9ja2luZ0ZpbGVzeXN0ZW1XcmFwcGVyIH0gZnJvbSAnLi4vLi4vLi4vbWFpbi9mcy13cmFwcGVyJztcblxuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi9zY2hlbWEnO1xuXG5cbmNvbnN0IFlBTUxfRVhUID0gJy55YW1sJztcblxuXG5pbnRlcmZhY2UgWUFNTCB7XG4gIFtwcm9wOiBzdHJpbmddOiBZQU1MXG59XG5cblxuaW50ZXJmYWNlIFlBTUxEaXJlY3RvcnlTdG9yZWFibGVDb250ZW50cyBleHRlbmRzIFlBTUwge1xuICBtZXRhOiBZQU1MXG59XG5cblxuZXhwb3J0IGNsYXNzIFlBTUxXcmFwcGVyPFQgZXh0ZW5kcyBZQU1MID0gWUFNTD4gZXh0ZW5kcyBBYnN0cmFjdExvY2tpbmdGaWxlc3lzdGVtV3JhcHBlcjxUPiB7XG4gIHByb3RlY3RlZCBpc1lBTUxGaWxlKG9iaklEOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcGF0aC5leHRuYW1lKG9iaklEKSA9PT0gWUFNTF9FWFQ7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaXNWYWxpZElEKG9iaklEOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5pc1lBTUxGaWxlKG9iaklEKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBhbmRQYXRoKG9iaklEOiBzdHJpbmcpIHtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHBhdGggdG8gb2JqZWN0IHNob3VsZCBpbmNsdWRlIFlBTUwgZXh0ZW5zaW9uLlxuICAgIHJldHVybiBgJHtzdXBlci5leHBhbmRQYXRoKG9iaklEKX0ke1lBTUxfRVhUfWA7XG4gIH1cblxuICBwcm90ZWN0ZWQgcGFyc2VEYXRhKGRhdGE6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHlhbWwubG9hZChkYXRhLCB7IHNjaGVtYTogU2NoZW1hIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGR1bXBEYXRhKGRhdGE6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geWFtbC5kdW1wKGRhdGEsIHtcbiAgICAgICAgc2NoZW1hOiBTY2hlbWEsXG4gICAgICAgIG5vUmVmczogdHJ1ZSxcbiAgICAgICAgbm9Db21wYXRNb2RlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBpbnZhbGlkIGRhdGEgKG51bGwgb3IgdW5kZWZpbmVkKVwiKTtcblxuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBZQU1MRGlyZWN0b3J5V3JhcHBlciBleHRlbmRzIFlBTUxXcmFwcGVyPFlBTUw+IHtcblxuICBjb25zdHJ1Y3RvcihiYXNlRGlyOiBzdHJpbmcpIHsgc3VwZXIoYmFzZURpcik7IH1cblxuICBwcml2YXRlIGV4cGFuZERpcmVjdG9yeVBhdGgob2JqSUQ6IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLmpvaW4odGhpcy5iYXNlRGlyLCBvYmpJRCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXhpc3RzKG9iaklEOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkaXJQYXRoID0gdGhpcy5leHBhbmREaXJlY3RvcnlQYXRoKG9iaklEKTtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhkaXJQYXRoKSkge1xuICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzLnN0YXQoZGlyUGF0aCk7XG4gICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGlzIGV4cGVjdGVkIHRvIGJlIGEgZGlyZWN0b3J5XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpc1ZhbGlkSUQodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1ldGFGaWxlID0gcGF0aC5qb2luKHRoaXMuZXhwYW5kRGlyZWN0b3J5UGF0aCh2YWx1ZSksIGBtZXRhJHtZQU1MX0VYVH1gKTtcbiAgICBsZXQgbWV0YUZpbGVJc0ZpbGU6IGJvb2xlYW47XG4gICAgdHJ5IHtcbiAgICAgIG1ldGFGaWxlSXNGaWxlID0gKGF3YWl0IGZzLnN0YXQobWV0YUZpbGUpKS5pc0ZpbGUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbWV0YUZpbGVJc0ZpbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFGaWxlSXNGaWxlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWQob2JqSUQ6IHN0cmluZywgbWV0YUZpZWxkczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBvYmpBYnNQYXRoID0gdGhpcy5leHBhbmREaXJlY3RvcnlQYXRoKG9iaklEKTtcblxuICAgIGNvbnN0IG1ldGFJZCA9ICdtZXRhJztcblxuICAgIGNvbnN0IG1ldGFBYnNQYXRoID0gcGF0aC5qb2luKG9iakFic1BhdGgsIGAke21ldGFJZH0ke1lBTUxfRVhUfWApO1xuICAgIGxldCBtZXRhRmlsZUlzRmlsZTogYm9vbGVhbjtcbiAgICB0cnkge1xuICAgICAgbWV0YUZpbGVJc0ZpbGUgPSAoYXdhaXQgZnMuc3RhdChtZXRhQWJzUGF0aCkpLmlzRmlsZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhjZXB0aW9uIGFjY2Vzc2luZyBtZXRhIGZpbGUgZm9yICR7b2JqSUR9OiAke21ldGFBYnNQYXRofTogJHtlLnRvU3RyaW5nKCl9ICR7ZS5zdGFja31gKTtcbiAgICB9XG4gICAgaWYgKCFtZXRhRmlsZUlzRmlsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRhIGZpbGUgZm9yICR7b2JqSUR9IGlzIG5vdCBhIGZpbGU6ICR7bWV0YUFic1BhdGh9YCk7XG4gICAgfVxuXG4gICAgdmFyIG9iakRhdGE6IFlBTUwgPSB7fTtcblxuICAgIGNvbnN0IG1ldGFQYXRoID0gcGF0aC5qb2luKG9iaklELCBtZXRhSWQpO1xuICAgIGNvbnN0IG1ldGEgPSBhd2FpdCBzdXBlci5yZWFkKG1ldGFQYXRoKSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBtZXRhRmllbGRzKSB7XG4gICAgICBvYmpEYXRhW2tleV0gPSBtZXRhW2tleSBhcyBzdHJpbmddO1xuICAgIH1cblxuICAgIGNvbnN0IGRpckNvbnRlbnRzID0gYXdhaXQgZnMucmVhZGRpcihvYmpBYnNQYXRoKTtcbiAgICBmb3IgKGNvbnN0IGZpbGVuYW1lIG9mIGRpckNvbnRlbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc1lBTUxGaWxlKGZpbGVuYW1lKSkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVuYW1lLCBZQU1MX0VYVCk7XG4gICAgICAgIGlmIChmaWVsZE5hbWUgIT0gJ21ldGEnKSB7XG4gICAgICAgICAgb2JqRGF0YVtmaWVsZE5hbWVdID0gYXdhaXQgc3VwZXIucmVhZChwYXRoLmpvaW4ob2JqSUQsIGZpZWxkTmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmxpbmRseSBob3BlIHRoYXQgZGF0YSBzdHJ1Y3R1cmUgbG9hZGVkIGZyb20gWUFNTFxuICAgIC8vIGlzIHZhbGlkIGZvciBnaXZlbiB0eXBlLlxuICAgIHJldHVybiBvYmpEYXRhO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHdyaXRlPFIgZXh0ZW5kcyBZQU1MPihvYmpJRDogc3RyaW5nLCBuZXdEYXRhPzogUiwgbWV0YUZpZWxkcz86IChrZXlvZiBSKVtdKSB7XG4gICAgY29uc3Qgb2JqUGF0aCA9IHRoaXMuZXhwYW5kRGlyZWN0b3J5UGF0aChvYmpJRCk7XG5cbiAgICBpZiAobmV3RGF0YSAhPT0gdW5kZWZpbmVkICYmIG1ldGFGaWVsZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXdhaXQgZnMuZW5zdXJlRGlyKG9ialBhdGgpO1xuXG4gICAgICB2YXIgZGF0YVRvU3RvcmU6IFlBTUxEaXJlY3RvcnlTdG9yZWFibGVDb250ZW50cyA9IHsgbWV0YToge30gfTtcbiAgICAgIHZhciBtb2RpZmllZFBhdGhzID0gW10gYXMgc3RyaW5nW107XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld0RhdGEpKSB7XG4gICAgICAgIGlmIChtZXRhRmllbGRzLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgZGF0YVRvU3RvcmUubWV0YVtrZXldID0gbmV3RGF0YVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFUb1N0b3JlW2tleV0gPSBuZXdEYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhVG9TdG9yZSkpIHtcbiAgICAgICAgbW9kaWZpZWRQYXRocyA9IFtcbiAgICAgICAgICAuLi5tb2RpZmllZFBhdGhzLFxuICAgICAgICAgIC4uLihhd2FpdCBzdXBlci53cml0ZShwYXRoLmpvaW4ob2JqSUQsIGZpZWxkTmFtZSksIGZpZWxkVmFsdWUpKSxcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGlmaWVkUGF0aHM7XG5cbiAgICB9IGVsc2UgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWV0YUZpZWxkcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdyaXRpbmcgYGB1bmRlZmluZWRgYCBzaG91bGQgY2F1c2UgRlMgd3JhcHBlciB0byBkZWxldGUgdGhlIGZpbGUgZnJvbSBmaWxlc3lzdGVtXG4gICAgICByZXR1cm4gc3VwZXIud3JpdGUob2JqSUQsIG5ld0RhdGEpO1xuICAgIH1cbiAgfVxufVxuIl19