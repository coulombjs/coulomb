{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/db/main/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { AnyIDType, Model } from '../models';\nimport { SettingManager } from '../../settings/main';\nimport { Index } from '../query';\nimport { BackendDescription } from '../base';\nimport { listen } from '../../ipc/main';\n\n\n// Generic backend.\n\nexport abstract class Backend<IDType = AnyIDType> {\n  abstract init(): Promise<void>\n  /* Initializes the backend.\n     This may involve loading data from remote storage,\n     thus initial authentication, etc. */\n\n  abstract describe(): Promise<BackendDescription<any>>\n\n  // Following are data query & update methods.\n  // One DB may operate a heterogeneous collection of objects.\n  // Recognizing their types is not within DB backend’s scope.\n  // These methods rather operate lower-level\n  // generic object payloads and object IDs.\n  //\n  // Recognizing particular data types is Manager’s job:\n  // the app would query data objects via corresponding manager,\n  // which in turn would call these methods\n  // filling in appropriate arguments.\n\n  abstract getIndex(idField: string, ...args: any[]): Promise<Index<any>>\n  // DEPRECATED: Reading all DB objects without any filtering query will be too slow.\n\n  abstract listIDs(query: object): Promise<IDType[]>\n  abstract read(objID: IDType, ...args: any[]): Promise<object>\n  abstract create(obj: object, ...args: any[]): Promise<void>\n  abstract update(objID: IDType, obj: object, ...args: any[]): Promise<void>\n  abstract delete(objID: IDType, ...args: any[]): Promise<void>\n\n  setUpIPC(dbID: string): void {\n    /* Initializes IPC endpoints to enable the user to e.g. configure the data store\n       or invoke housekeeping or utility routines. */\n\n    const prefix = `db-${dbID}`;\n\n    listen<{}, BackendDescription<any>>\n    (`${prefix}-describe`, async () => {\n      return await this.describe();\n    });\n\n    listen<{ objectID: IDType | null }, { object: object | null }>\n    (`${prefix}-read`, async ({ objectID }) => {\n      if (objectID === null) {\n        return { object: null };\n      } else {\n        return { object: await this.read(objectID) };\n      }\n    });\n  }\n}\n\n\nexport type ManagedDataChangeReporter<IDType> =\n(changedIDs?: IDType[]) => Promise<void>;\n/* Function of this signature will be passed to manager constructor,\n   to be called when manager reports data updates to app windows,\n   letting any object lists re-query the data.\n\n   `changedIDs` is intended to avoid unnecessary re-querying.\n   An object referenced in it may have been created,\n   modified or deleted.\n   \n   Manager must omit `changedIDs` if it is not sure\n   which exactly objects did change. */\n\n\nexport type BackendStatusReporter<Status> =\n(payload: Partial<Status>) => Promise<void>;\n/* Function of this signature will be passed to backend constructor,\n   to be called when backend needs to report status to app windows. */\n\n\nexport interface BackendClass<\n    InitialOptions extends object,\n    Options extends InitialOptions,\n    Status extends object> {\n  /* Initial options are supplied by the developer.\n     Full options include options configurable by the user, some of which may be required.\n\n     NOTE: By “Option”, backend constructor parameter is meant.\n     TODO: This is a misnomer since some of those are non-optional. */\n\n  new (\n    options: Options,\n    reportBackendStatus: BackendStatusReporter<Status>,\n  ): Backend\n  // Backend classes are instantiated by the framework during app initialization.\n\n  registerSettingsForConfigurableOptions?(\n    settings: SettingManager,\n    initialOptions: Partial<InitialOptions>,\n    dbID: string): void\n  /* Given initial options and a settings manager,\n     register user-configurable settings that control this DB’s behavior.\n     This method can make a setting required if corresponding option\n     is not provided by the developer in the initial options. */\n\n  completeOptionsFromSettings?(\n    settings: SettingManager,\n    initialOptions: Partial<InitialOptions>,\n    dbID: string): Promise<Options>\n  /* Given initial options and a settings manager,\n     retrieve any user-configured options if needed\n     and return full options object required by this backend. */\n}\n\n\n// Versioned backend & compatible manager.\n\nexport abstract class VersionedBackend<IDType = AnyIDType> extends Backend<IDType> {\n\n  abstract discard(objIDs: IDType[]): Promise<void>\n  /* Discard any uncommitted changes made to objects with specified IDs. */\n\n  abstract commit(objIDs: IDType[], commitMessage: string): Promise<void>\n  /* Commit any uncommitted changes made to objects with specified IDs,\n     with specified commit message. */\n\n  abstract listUncommitted?(): Promise<IDType[]>\n  /* List IDs of objects with uncommitted changes. */\n\n}\n\n\nexport abstract class ModelManager<M extends Model, IDType extends AnyIDType, Q extends object = object> {\n  /* Passes calls on to corresponding Backend (or subclass) methods,\n     but limits their scope only to objects manipulated by this manager. */\n\n  abstract count(query?: Q): Promise<number>\n  abstract reportUpdatedData: ManagedDataChangeReporter<IDType>\n\n  abstract listIDs(query?: Q): Promise<IDType[]>\n  // TODO: Returned IDs cannot automatically be cast to IDType;\n  // get rid of IDType generic and manage types in subclasses?\n\n  abstract readAll(query?: Q): Promise<Index<M>>\n  abstract read(id: IDType): Promise<M>\n  abstract create(obj: M, ...args: any[]): Promise<void>\n  abstract update(objID: IDType, obj: M, ...args: any[]): Promise<void>\n  abstract delete(objID: IDType, ...args: unknown[]): Promise<void>\n\n  protected abstract getDBRef(objID: IDType | string): string\n  protected abstract getObjID(dbRef: string): IDType\n\n  async init() {}\n\n  setUpIPC(modelName: string) {\n    /* Initializes IPC endpoints to query or update data objects. */\n\n    const prefix = `model-${modelName}`;\n\n    listen<{ query?: Q }, { ids: IDType[] }>\n    (`${prefix}-list-ids`, async ({ query }) => ({ ids: (await this.listIDs(query)) }));\n\n    listen<{ query?: Q }, { count: number }>\n    (`${prefix}-count`, async ({ query }) => ({ count: await this.count(query) }));\n\n    listen<{ query?: Q }, Index<M>>\n    (`${prefix}-read-all`, async ({ query }) => this.readAll(query));\n\n    listen<{ objectID: IDType | null }, { object: M | null }>\n    (`${prefix}-read-one`, async ({ objectID }) => {\n      if (objectID === null) {\n        return { object: null };\n      } else {\n        return { object: await this.read(objectID) };\n      }\n    });\n\n    listen<{ objectID: IDType, object: M, commit: boolean }, { success: true }>\n    (`${prefix}-update-one`, async ({ objectID, object, commit }) => {\n      await this.update(objectID, object, commit);\n      return { success: true };\n    });\n\n    listen<{ objectID: IDType }, { success: true }>\n    (`${prefix}-delete-one`, async ({ objectID }) => {\n      await this.delete(objectID, true);\n      return { success: true };\n    });\n\n    listen<{ object: M, commit: boolean }, { success: true }>\n    (`${prefix}-create-one`, async ({ object, commit }) => {\n      await this.create(object, commit);\n      return { success: true };\n    });\n  }\n}\n\n\nexport class CommitError extends Error {\n  constructor(public code: string, msg: string) {\n    super(msg);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\n\n// Versioned backend specifically based on local filesystem,\n// and requisite manager interface\n\nexport abstract class VersionedFilesystemBackend extends VersionedBackend<string> {\n\n  abstract getIndex(idField: string, subdir: string, onlyIDs?: string[]): Promise<Index<any>>\n\n  abstract getLocalFilesystemPath(id: string): Promise<string>\n\n  abstract registerManager(manager: FilesystemManager): void\n  /* Enables instances of this backend to keep track of managers,\n     which is required for the purpose of excluding files\n     created arbitrarily by OS or other software\n     from version control (see `resetOrphanedFileChanges()`).\n\n     NOTE: So far this is the only reason DB backend needs to keep track\n     of associated managers.\n     Could DB backend be made aware of which files\n     it’s responsible for?\n     Avoiding this dependency on managers\n     would be beneficial, if there’s an elegant way of doing it. */\n\n  abstract resetOrphanedFileChanges(): Promise<void>\n  /* Housekeeping method for file-based DB backend. */\n\n}\n\n\nexport interface FilesystemManager {\n\n  getLocalFilesystemPath(id: AnyIDType): Promise<string>\n\n  managesFileAtPath(filePath: string): boolean\n  /* Determines whether the manager instance is responsible for the file\n     under given path. */\n}\n"]}