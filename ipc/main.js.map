{"version":3,"file":"main.js","sourceRoot":"","sources":["../../src/ipc/main.ts"],"names":[],"mappings":"AAAA;0FAC0F;AAE1F,OAAO,KAAK,GAAG,MAAM,cAAc,CAAC;AAEpC,OAAO,EAAE,OAAO,EAAE,MAAM,UAAU,CAAC;AACnC,OAAO,EAAE,gBAAgB,EAAE,UAAU,EAAsB,MAAM,gBAAgB,CAAC;AAClF,OAAO,EAAe,8BAA8B,EAAE,MAAM,qBAAqB,CAAC;AAElF,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAI1C,MAAM,UAAU,MAAM,CACrB,IAAY,EAAE,OAAsB;IACnC;;;;;;;;qCAQiC;IAEjC,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,EAAE,GAAQ,EAAE,QAAiB,EAAE,EAAE;QACzD,IAAI,QAAwB,CAAC;QAE7B,wEAAwE;QACxE,0DAA0D;QAC1D,MAAM,KAAK,GAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,IAAI,EAAE,eAAe,CAAC,CAAC;QAE/D,IAAI;YACF,QAAQ,GAAG,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;SACzD;QAAC,OAAO,CAAC,EAAE;YACV,GAAG,CAAC,KAAK,CAAC,oCAAoC,IAAI,KAAK,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;YACpF,QAAQ,GAAG,EAAE,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC;SAC5D;QAED,iDAAiD;QAEjD,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;AACL,CAAC;AAGD,MAAM,UAAU,QAAQ,CAAC,SAAiB,EAAE,OAA0B;IACpE,mDAAmD;IACnD,OAAO,OAAO,CAAC,cAAc,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AACpD,CAAC;AAGD,oDAAoD;AACpD,oDAAoD;AACpD,qDAAqD;AACrD,MAAM,CACL,4BAA4B,EAAE,KAAK,EAAE,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE,EAAE;IAC9D,MAAM,gBAAgB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;IAC3C,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;AAC3B,CAAC,CAAC,CAAC;AAGH,MAAM,UAAU,kBAAkB,CAAC,IAAY,EAAE,aAAkD;IACjG,6BAA6B;IAC7B,MAAM,UAAU,GAAG,8BAA8B,CAAC,IAAI,CAAC,CAAC;IAExD,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,EAAE,GAAQ,EAAE,MAAe,EAAE,EAAE;QACjE,MAAM,YAAY,GAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,EAAE,eAAe,CAAC,CAAC;QACtE,MAAM,UAAU,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC;QAE9C,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;QAC9C,GAAG,CAAC,WAAW,GAAG,MAAM,CAAC;QACzB,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/* Simple API on top of Electron’s IPC framework, the `main` side.\n   Provides functions for handling API requests to fetch/store data and/or open window. */\n\nimport * as log from 'electron-log';\n\nimport { ipcMain } from 'electron';\nimport { notifyAllWindows, openWindow, WindowOpenerParams } from '../main/window';\nimport { APIResponse, getEventNamesForWindowEndpoint } from '../api_legacy/utils';\n\nimport { reviveJsonValue } from './utils';\n\n\nexport type Handler<I extends object, O extends object> = (params: I) => Promise<O>;\nexport function listen<I extends object, O extends object>\n(name: string, handler: Handler<I, O>) {\n  /* Defines an API endpoint with I input and O output types.\n     Takes endpoint name and handler function.\n\n     Handler is expected to be an async function\n     that takes deserialized input params and returns the output.\n\n     The endpoint handles input deserialization,\n     wrapping the output in response object { errors: string[], result: O },\n     and response serialization. */\n\n  ipcMain.handle(name, async (evt: any, rawInput?: string) => {\n    let response: APIResponse<O>;\n\n    // We may be able to switch to Electron’s own (de)serialization behavior\n    // if we find a way to plug our bespoke `reviveJsonValue`.\n    const input: I = JSON.parse(rawInput || '{}', reviveJsonValue);\n\n    try {\n      response = { errors: [], result: await handler(input) };\n    } catch (e) {\n      log.error(`C/ipc: Error handling request to ${name}! ${e.toString()}: ${e.stack}}`);\n      response = { errors: [`${e.message}`], result: undefined };\n    }\n\n    //log.silly(`C/ipc: handled request to ${name}`);\n\n    return JSON.stringify(response);\n  });\n}\n\n\nexport function unlisten(eventName: string, handler: Handler<any, any>) {\n  /* Removes event listener created with listen(). */\n  return ipcMain.removeListener(eventName, handler);\n}\n\n\n// See also ipc.renderer.useIPCWindowEventRelayer().\n// Used if one window needs to notify other windows.\n// NOTE: Generally discouraged, somewhat of a crutch.\nlisten<{ eventName: string, payload?: any }, { success: true }>\n('relay-event-to-all-windows', async ({ eventName, payload }) => {\n  await notifyAllWindows(eventName, payload);\n  return { success: true };\n});\n\n\nexport function makeWindowEndpoint(name: string, getWindowOpts: (params: any) => WindowOpenerParams): void {\n  // TODO: Migrate to listen()?\n  const eventNames = getEventNamesForWindowEndpoint(name);\n\n  ipcMain.on(eventNames.request, async (evt: any, params?: string) => {\n    const parsedParams: any = JSON.parse(params || '{}', reviveJsonValue);\n    await openWindow(getWindowOpts(parsedParams));\n\n    const result = JSON.stringify({ errors: [] });\n    evt.returnValue = result;\n    evt.reply(eventNames.response, result);\n  });\n}\n"]}