/* Wraps IPC communication in React hooks & locking queue. */
import AsyncLock from 'async-lock';
import * as log from 'electron-log';
import { ipcRenderer } from 'electron';
import { useEffect, useState } from 'react';
import { reviveJsonValue } from './utils';
class IPCFailure extends Error {
    constructor(errorMessageList) {
        super(errorMessageList.join('; '));
        this.errorMessageList = errorMessageList;
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
export function useIPCEvent(endpointName, handler) {
    /* Sets up main -> renderer event listener & cleanup on component destruction. */
    useEffect(() => {
        function handleEvent(evt, payload) {
            log.debug("C/ipc/useIPCEvent: Handling IPC event", endpointName);
            handler(payload);
        }
        ipcRenderer.on(endpointName, handleEvent);
        return function cleanup() {
            ipcRenderer.removeListener(endpointName, handleEvent);
        };
    }, []);
}
export function useIPCValue(endpointName, initialValue, payload) {
    /* Invokes an endpoint and provides result state in the form of a hook.
       State can be updated by calling `refresh()`. */
    const [value, updateValue] = useState(initialValue);
    const [errors, updateErrors] = useState([]);
    const [isUpdating, setUpdating] = useState(true);
    const [reqCounter, updateReqCounter] = useState(0);
    const payloadSnapshot = JSON.stringify(payload || {});
    useEffect(() => {
        let cancelled = false;
        async function doQuery() {
            setUpdating(true);
            const resp = await ipcRenderer.invoke(endpointName, payloadSnapshot);
            const data = JSON.parse(resp, reviveJsonValue);
            if (cancelled) {
                return;
            }
            if (data.errors !== undefined) {
                const resp = data;
                if (resp.result === undefined) {
                    if (resp.errors.length > 0) {
                        updateErrors(resp.errors);
                    }
                    else {
                        updateErrors(["Unknown error"]);
                    }
                    updateValue(initialValue);
                }
                else {
                    updateErrors([]);
                    updateValue(data.result);
                }
            }
            else {
                updateValue(data);
            }
            setUpdating(false);
        }
        ;
        doQuery();
        return () => {
            cancelled = true;
        };
    }, [endpointName, reqCounter, payloadSnapshot]);
    return {
        value: value,
        errors: errors,
        isUpdating: isUpdating,
        refresh: () => updateReqCounter(counter => { return counter += 1; }),
        _reqCounter: reqCounter,
    };
}
export async function callIPC(endpointName, payload) {
    return ipcEndpointRequestLock.acquire(endpointName, async function () {
        const rawData = await ipcRenderer.invoke(endpointName, JSON.stringify(payload));
        return new Promise((resolve, reject) => {
            const data = JSON.parse(rawData, reviveJsonValue);
            if (data.errors !== undefined) {
                // Means main is using listen(), new API
                const resp = data;
                if (resp.result === undefined) {
                    if (resp.errors.length > 0) {
                        reject(new IPCFailure(resp.errors));
                    }
                    else {
                        reject(new IPCFailure(["Unknown error"]));
                    }
                }
                resolve(data.result);
            }
            else {
                // Means main is using makeEndpoint(), legacy API
                const result = data;
                resolve(result);
            }
        });
    });
}
export async function relayIPCEvent(payload) {
    return await callIPC('relay-event-to-all-windows', payload);
}
const ipcEndpointRequestLock = new AsyncLock({ maxPending: 100000 });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaXBjL3JlbmRlcmVyLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7QUFFN0QsT0FBTyxTQUFTLE1BQU0sWUFBWSxDQUFDO0FBQ25DLE9BQU8sS0FBSyxHQUFHLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFFNUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQVMxQyxNQUFNLFVBQVcsU0FBUSxLQUFLO0lBQzVCLFlBQW1CLGdCQUEwQjtRQUMzQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFEbEIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFVO1FBRTNDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEQsQ0FBQztDQUNGO0FBR0QsTUFBTSxVQUFVLFdBQVcsQ0FDMUIsWUFBb0IsRUFBRSxPQUE2QjtJQUNsRCxpRkFBaUY7SUFFakYsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLFNBQVMsV0FBVyxDQUFDLEdBQW1CLEVBQUUsT0FBVTtZQUNsRCxHQUFHLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBQ2pFLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuQixDQUFDO1FBQ0QsV0FBVyxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDMUMsT0FBTyxTQUFTLE9BQU87WUFDckIsV0FBVyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDeEQsQ0FBQyxDQUFBO0lB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RUFBRSxNQUFNLEVBQUUsRUFBRTtZQUN4QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztZQUNsRCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO2dCQUM3Qix3Q0FBd0M7Z0JBQ3hDLE1BQU0sSUFBSSxHQUFtQixJQUFJLENBQUM7Z0JBRWxDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7b0JBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO3dCQUMxQixNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7cUJBQ3JDO3lCQUFNO3dCQUNMLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDM0M7aUJBQ0Y7Z0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN0QjtpQkFBTTtnQkFDTCxpREFBaUQ7Z0JBQ2pELE1BQU0sTUFBTSxHQUFNLElBQUksQ0FBQztnQkFDdkIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ2pCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFHRCxNQUFNLENBQUMsS0FBSyxVQUFVLGFBQWEsQ0FLbEMsT0FBVTtJQUNULE9BQU8sTUFBTSxPQUFPLENBQU8sNEJBQTRCLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDcEUsQ0FBQztBQVlELE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxTQUFTLENBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFdyYXBzIElQQyBjb21tdW5pY2F0aW9uIGluIFJlYWN0IGhvb2tzICYgbG9ja2luZyBxdWV1ZS4gKi9cblxuaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdlbGVjdHJvbi1sb2cnO1xuaW1wb3J0IHsgaXBjUmVuZGVyZXIgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyByZXZpdmVKc29uVmFsdWUgfSBmcm9tICcuL3V0aWxzJztcblxuXG50eXBlIElQQ1Jlc3BvbnNlPE8+ID0ge1xuICBlcnJvcnM6IHN0cmluZ1tdXG4gIHJlc3VsdDogTyB8IHVuZGVmaW5lZFxufTtcblxuXG5jbGFzcyBJUENGYWlsdXJlIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZXJyb3JNZXNzYWdlTGlzdDogc3RyaW5nW10pIHtcbiAgICBzdXBlcihlcnJvck1lc3NhZ2VMaXN0LmpvaW4oJzsgJykpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSVBDRXZlbnQ8UCBleHRlbmRzIG9iamVjdD5cbihlbmRwb2ludE5hbWU6IHN0cmluZywgaGFuZGxlcjogKHBheWxvYWQ6IFApID0+IHZvaWQpIHtcbiAgLyogU2V0cyB1cCBtYWluIC0+IHJlbmRlcmVyIGV2ZW50IGxpc3RlbmVyICYgY2xlYW51cCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uICovXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudChldnQ6IEVsZWN0cm9uLkV2ZW50LCBwYXlsb2FkOiBQKSB7XG4gICAgICBsb2cuZGVidWcoXCJDL2lwYy91c2VJUENFdmVudDogSGFuZGxpbmcgSVBDIGV2ZW50XCIsIGVuZHBvaW50TmFtZSk7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH1cbiAgICBpcGNSZW5kZXJlci5vbihlbmRwb2ludE5hbWUsIGhhbmRsZUV2ZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIGlwY1JlbmRlcmVyLnJlbW92ZUxpc3RlbmVyKGVuZHBvaW50TmFtZSwgaGFuZGxlRXZlbnQpO1xuICAgIH1cbiAgfSwgW10pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJUENWYWx1ZTxJIGV4dGVuZHMgb2JqZWN0LCBPPlxuKGVuZHBvaW50TmFtZTogc3RyaW5nLCBpbml0aWFsVmFsdWU6IE8sIHBheWxvYWQ/OiBJKTogSVBDSG9vazxPPiB7XG4gIC8qIEludm9rZXMgYW4gZW5kcG9pbnQgYW5kIHByb3ZpZGVzIHJlc3VsdCBzdGF0ZSBpbiB0aGUgZm9ybSBvZiBhIGhvb2suXG4gICAgIFN0YXRlIGNhbiBiZSB1cGRhdGVkIGJ5IGNhbGxpbmcgYHJlZnJlc2goKWAuICovXG5cbiAgY29uc3QgW3ZhbHVlLCB1cGRhdGVWYWx1ZV0gPSB1c2VTdGF0ZShpbml0aWFsVmFsdWUpO1xuICBjb25zdCBbZXJyb3JzLCB1cGRhdGVFcnJvcnNdID0gdXNlU3RhdGUoW10gYXMgc3RyaW5nW10pO1xuICBjb25zdCBbaXNVcGRhdGluZywgc2V0VXBkYXRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgY29uc3QgW3JlcUNvdW50ZXIsIHVwZGF0ZVJlcUNvdW50ZXJdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IHBheWxvYWRTbmFwc2hvdCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQgfHwge30pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZG9RdWVyeSgpIHtcbiAgICAgIHNldFVwZGF0aW5nKHRydWUpO1xuXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgaXBjUmVuZGVyZXIuaW52b2tlKGVuZHBvaW50TmFtZSwgcGF5bG9hZFNuYXBzaG90KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3AsIHJldml2ZUpzb25WYWx1ZSk7XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChkYXRhLmVycm9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBkYXRhIGFzIElQQ1Jlc3BvbnNlPE8+O1xuXG4gICAgICAgIGlmIChyZXNwLnJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVwZGF0ZUVycm9ycyhyZXNwLmVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUVycm9ycyhbXCJVbmtub3duIGVycm9yXCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlVmFsdWUoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVFcnJvcnMoW10pO1xuICAgICAgICAgIHVwZGF0ZVZhbHVlKGRhdGEucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlVmFsdWUoZGF0YSBhcyBPKTtcbiAgICAgIH1cblxuICAgICAgc2V0VXBkYXRpbmcoZmFsc2UpO1xuICAgIH07XG5cbiAgICBkb1F1ZXJ5KCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSwgW2VuZHBvaW50TmFtZSwgcmVxQ291bnRlciwgcGF5bG9hZFNuYXBzaG90XSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgaXNVcGRhdGluZzogaXNVcGRhdGluZyxcbiAgICByZWZyZXNoOiAoKSA9PiB1cGRhdGVSZXFDb3VudGVyKGNvdW50ZXIgPT4geyByZXR1cm4gY291bnRlciArPSAxIH0pLFxuICAgIF9yZXFDb3VudGVyOiByZXFDb3VudGVyLFxuICB9O1xufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsSVBDPEkgZXh0ZW5kcyBvYmplY3QsIE8+XG4oZW5kcG9pbnROYW1lOiBzdHJpbmcsIHBheWxvYWQ/OiBJKTogUHJvbWlzZTxPPiB7XG4gIHJldHVybiBpcGNFbmRwb2ludFJlcXVlc3RMb2NrLmFjcXVpcmUoZW5kcG9pbnROYW1lLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcmF3RGF0YSA9IGF3YWl0IGlwY1JlbmRlcmVyLmludm9rZShlbmRwb2ludE5hbWUsIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Tz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSwgcmV2aXZlSnNvblZhbHVlKTtcbiAgICAgIGlmIChkYXRhLmVycm9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE1lYW5zIG1haW4gaXMgdXNpbmcgbGlzdGVuKCksIG5ldyBBUElcbiAgICAgICAgY29uc3QgcmVzcDogSVBDUmVzcG9uc2U8Tz4gPSBkYXRhO1xuXG4gICAgICAgIGlmIChyZXNwLnJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgSVBDRmFpbHVyZShyZXNwLmVycm9ycykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IElQQ0ZhaWx1cmUoW1wiVW5rbm93biBlcnJvclwiXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGRhdGEucmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lYW5zIG1haW4gaXMgdXNpbmcgbWFrZUVuZHBvaW50KCksIGxlZ2FjeSBBUElcbiAgICAgICAgY29uc3QgcmVzdWx0OiBPID0gZGF0YTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVsYXlJUENFdmVudFxuPFxuICBJIGV4dGVuZHMgb2JqZWN0ID0geyBldmVudE5hbWU6IHN0cmluZywgZXZlbnRQYXlsb2FkPzogYW55IH0sXG4gIE8gPSB7IHN1Y2Nlc3M6IHRydWUgfSxcbj5cbihwYXlsb2FkOiBJKTogUHJvbWlzZTxPPiB7XG4gIHJldHVybiBhd2FpdCBjYWxsSVBDPEksIE8+KCdyZWxheS1ldmVudC10by1hbGwtd2luZG93cycsIHBheWxvYWQpO1xufVxuXG5cbmludGVyZmFjZSBJUENIb29rPFQ+IHtcbiAgdmFsdWU6IFRcbiAgZXJyb3JzOiBzdHJpbmdbXVxuICBpc1VwZGF0aW5nOiBib29sZWFuXG4gIHJlZnJlc2g6ICgpID0+IHZvaWRcbiAgX3JlcUNvdW50ZXI6IG51bWJlclxufVxuXG5cbmNvbnN0IGlwY0VuZHBvaW50UmVxdWVzdExvY2sgPSBuZXcgQXN5bmNMb2NrKHsgbWF4UGVuZGluZzogMTAwMDAwIH0pOyJdfQ==