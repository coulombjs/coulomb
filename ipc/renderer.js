/* Wraps IPC communication in React hooks & locking queue. */
import { debounce } from 'throttle-debounce';
import AsyncLock from 'async-lock';
import * as log from 'electron-log';
import { ipcRenderer } from 'electron';
import { useEffect, useState } from 'react';
import { reviveJsonValue } from './utils';
var cache = {};
class IPCFailure extends Error {
    constructor(errorMessageList) {
        super(errorMessageList.join('; '));
        this.errorMessageList = errorMessageList;
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
export function useIPCEvent(endpointName, handler) {
    /* Sets up main -> renderer event listener & cleanup on component destruction. */
    useEffect(() => {
        function handleEvent(evt, payload) {
            log.debug("Handling IPC event", endpointName);
            handler(payload);
        }
        ipcRenderer.on(endpointName, handleEvent);
        return function cleanup() {
            ipcRenderer.removeListener(endpointName, handleEvent);
        };
    }, []);
}
export function useIPCValue(endpointName, initialValue, payload) {
    /* Invokes an endpoint and provides result state in the form of a hook.
       State can be updated by calling `refresh()`. */
    const [value, updateValue] = useState(initialValue);
    const [errors, updateErrors] = useState([]);
    const [reqCounter, updateReqCounter] = useState(0);
    const payloadSnapshot = JSON.stringify(payload || {});
    useEffect(() => {
        const cacheKey = `${endpointName}${reqCounter}${payloadSnapshot}`;
        const doQuery = debounce(400, async () => {
            let resp;
            const cachedResp = cache[cacheKey];
            if (cachedResp !== undefined) {
                resp = cachedResp;
            }
            else {
                //(async () => {
                //updateValue(initialValue);
                resp = await ipcEndpointRequestLock.acquire(endpointName, async function () {
                    const payloadToSend = JSON.stringify(payload || {});
                    return await ipcRenderer.invoke(endpointName, payloadToSend);
                });
                cache[cacheKey] = resp;
                //})();
            }
            const data = JSON.parse(resp, reviveJsonValue);
            if (data.errors !== undefined) {
                const resp = data;
                if (resp.result === undefined) {
                    if (resp.errors.length > 0) {
                        updateErrors(resp.errors);
                    }
                    else {
                        updateErrors(["Unknown error"]);
                    }
                }
                else {
                    updateValue(data.result);
                }
            }
            else {
                updateValue(data);
            }
        });
        doQuery();
    }, [reqCounter, payloadSnapshot]);
    return {
        value: value,
        errors: errors,
        refresh: () => updateReqCounter(counter => { return counter += 1; }),
        _reqCounter: reqCounter,
    };
}
export async function callIPC(endpointName, payload) {
    return ipcEndpointRequestLock.acquire(endpointName, async function () {
        const rawData = await ipcRenderer.invoke(endpointName, JSON.stringify(payload));
        return new Promise((resolve, reject) => {
            const data = JSON.parse(rawData, reviveJsonValue);
            if (data.errors !== undefined) {
                // Means main is using listen(), new API
                const resp = data;
                if (resp.result === undefined) {
                    if (resp.errors.length > 0) {
                        reject(new IPCFailure(resp.errors));
                    }
                    else {
                        reject(new IPCFailure(["Unknown error"]));
                    }
                }
                resolve(data.result);
            }
            else {
                // Means main is using makeEndpoint(), legacy API
                const result = data;
                resolve(result);
            }
        });
    });
}
export async function relayIPCEvent(payload) {
    return await callIPC('relay-event-to-all-windows', payload);
}
const ipcEndpointRequestLock = new AsyncLock({ maxPending: 100000 });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaXBjL3JlbmRlcmVyLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7QUFFN0QsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzdDLE9BQU8sU0FBUyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEtBQUssR0FBRyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBRTVDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFHMUMsSUFBSSxLQUFLLEdBQTBCLEVBQUUsQ0FBQztBQVN0QyxNQUFNLFVBQVcsU0FBUSxLQUFLO0lBQzVCLFlBQW1CLGdCQUEwQjtRQUMzQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFEbEIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFVO1FBRTNDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEQsQ0FBQztDQUNGO0FBR0QsTUFBTSxVQUFVLFdBQVcsQ0FDMUIsWUFBb0IsRUFBRSxPQUE2QjtJQUNsRCxpRkFBaUY7SUFFakYsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLFNBQVMsV0FBVyxDQUFDLEdBQW1CLEVBQUUsT0FBVTtZQUNsRCxHQUFHLENBQUMsS0FBSyxDQUFDLG9CQUFvQixFQUFFLFlBQVksQ0FBQyxDQUFDO1lBQzlDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuQixDQUFDO1FBQ0QsV0FBVyxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDMUMsT0FBTyxTQUFTLE9BQU87WUFDckIsV0FBVyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDeEQsQ0FBQyxDQUFBO0lBQ0gsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ1QsQ0FBQztBQUdELE1BQU0sVUFBVSxXQUFXLENBQzFCLFlBQW9CLEVBQUUsWUFBZSxFQUFFLE9BQVc7SUFDakQ7c0RBQ2tEO0lBRWxELE1BQU0sQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3BELE1BQU0sQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLEdBQUcsUUFBUSxDQUFDLEVBQWMsQ0FBQyxDQUFDO0lBRXhELE1BQU0sQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUM7SUFFdEQsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLE1BQU0sUUFBUSxHQUFHLEdBQUcsWUFBWSxHQUFHLFVBQVUsR0FBRyxlQUFlLEVBQUUsQ0FBQztRQUVsRSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBRXZDLElBQUksSUFBWSxDQUFDO1lBQ2pCLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVuQyxJQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7Z0JBQzVCLElBQUksR0FBRyxVQUFVLENBQUM7YUFDbkI7aUJBQU07Z0JBQ0wsZ0JBQWdCO2dCQUNoQiw0QkFBNEI7Z0JBRTVCLElBQUksR0FBRyxNQUFNLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsS0FBSztvQkFDN0QsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQ3BELE9BQU8sTUFBTSxXQUFXLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxhQUFhLENBQUMsQ0FBQztnQkFDL0QsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDdkIsT0FBTzthQUNSO1lBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFFL0MsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEdBQUcsSUFBc0IsQ0FBQztnQkFFcEMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtvQkFDN0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQzFCLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7cUJBQzNCO3lCQUFNO3dCQUNMLFlBQVksQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7cUJBQ2pDO2lCQUNGO3FCQUFNO29CQUNMLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQzFCO2FBQ0Y7aUJBQU07Z0JBQ0wsV0FBVyxDQUFDLElBQVMsQ0FBQyxDQUFDO2FBQ3hCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO0lBRWxDLE9BQU87UUFDTCxLQUFLLEVBQUUsS0FBSztRQUNaLE1BQU0sRUFBRSxNQUFNO1FBQ2QsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsT0FBTyxPQUFPLElBQUksQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDO1FBQ25FLFdBQVcsRUFBRSxVQUFVO0tBQ3hCLENBQUM7QUFDSixDQUFDO0FBR0QsTUFBTSxDQUFDLEtBQUssVUFBVSxPQUFPLENBQzVCLFlBQW9CLEVBQUUsT0FBVztJQUNoQyxPQUFPLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsS0FBSztRQUN2RCxNQUFNLE9BQU8sR0FBRyxNQUFNLFdBQVcsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNoRixPQUFPLElBQUksT0FBTyxDQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3hDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBQ2xELElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7Z0JBQzdCLHdDQUF3QztnQkFDeEMsTUFBTSxJQUFJLEdBQW1CLElBQUksQ0FBQztnQkFFbEMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtvQkFDN0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQzFCLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztxQkFDckM7eUJBQU07d0JBQ0wsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUMzQztpQkFDRjtnQkFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3RCO2lCQUFNO2dCQUNMLGlEQUFpRDtnQkFDakQsTUFBTSxNQUFNLEdBQU0sSUFBSSxDQUFDO2dCQUN2QixPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDakI7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUdELE1BQU0sQ0FBQyxLQUFLLFVBQVUsYUFBYSxDQUtsQyxPQUFVO0lBQ1QsT0FBTyxNQUFNLE9BQU8sQ0FBTyw0QkFBNEIsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBV0QsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLFNBQVMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogV3JhcHMgSVBDIGNvbW11bmljYXRpb24gaW4gUmVhY3QgaG9va3MgJiBsb2NraW5nIHF1ZXVlLiAqL1xuXG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3Rocm90dGxlLWRlYm91bmNlJztcbmltcG9ydCBBc3luY0xvY2sgZnJvbSAnYXN5bmMtbG9jayc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnZWxlY3Ryb24tbG9nJztcbmltcG9ydCB7IGlwY1JlbmRlcmVyIH0gZnJvbSAnZWxlY3Ryb24nO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgcmV2aXZlSnNvblZhbHVlIH0gZnJvbSAnLi91dGlscyc7XG5cblxudmFyIGNhY2hlOiB7IFtpZDogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuXG50eXBlIElQQ1Jlc3BvbnNlPE8+ID0ge1xuICBlcnJvcnM6IHN0cmluZ1tdXG4gIHJlc3VsdDogTyB8IHVuZGVmaW5lZFxufTtcblxuXG5jbGFzcyBJUENGYWlsdXJlIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZXJyb3JNZXNzYWdlTGlzdDogc3RyaW5nW10pIHtcbiAgICBzdXBlcihlcnJvck1lc3NhZ2VMaXN0LmpvaW4oJzsgJykpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSVBDRXZlbnQ8UCBleHRlbmRzIG9iamVjdD5cbihlbmRwb2ludE5hbWU6IHN0cmluZywgaGFuZGxlcjogKHBheWxvYWQ6IFApID0+IHZvaWQpIHtcbiAgLyogU2V0cyB1cCBtYWluIC0+IHJlbmRlcmVyIGV2ZW50IGxpc3RlbmVyICYgY2xlYW51cCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uICovXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudChldnQ6IEVsZWN0cm9uLkV2ZW50LCBwYXlsb2FkOiBQKSB7XG4gICAgICBsb2cuZGVidWcoXCJIYW5kbGluZyBJUEMgZXZlbnRcIiwgZW5kcG9pbnROYW1lKTtcbiAgICAgIGhhbmRsZXIocGF5bG9hZCk7XG4gICAgfVxuICAgIGlwY1JlbmRlcmVyLm9uKGVuZHBvaW50TmFtZSwgaGFuZGxlRXZlbnQpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgaXBjUmVuZGVyZXIucmVtb3ZlTGlzdGVuZXIoZW5kcG9pbnROYW1lLCBoYW5kbGVFdmVudCk7XG4gICAgfVxuICB9LCBbXSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlQQ1ZhbHVlPEkgZXh0ZW5kcyBvYmplY3QsIE8+XG4oZW5kcG9pbnROYW1lOiBzdHJpbmcsIGluaXRpYWxWYWx1ZTogTywgcGF5bG9hZD86IEkpOiBJUENIb29rPE8+IHtcbiAgLyogSW52b2tlcyBhbiBlbmRwb2ludCBhbmQgcHJvdmlkZXMgcmVzdWx0IHN0YXRlIGluIHRoZSBmb3JtIG9mIGEgaG9vay5cbiAgICAgU3RhdGUgY2FuIGJlIHVwZGF0ZWQgYnkgY2FsbGluZyBgcmVmcmVzaCgpYC4gKi9cblxuICBjb25zdCBbdmFsdWUsIHVwZGF0ZVZhbHVlXSA9IHVzZVN0YXRlKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IFtlcnJvcnMsIHVwZGF0ZUVycm9yc10gPSB1c2VTdGF0ZShbXSBhcyBzdHJpbmdbXSk7XG5cbiAgY29uc3QgW3JlcUNvdW50ZXIsIHVwZGF0ZVJlcUNvdW50ZXJdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IHBheWxvYWRTbmFwc2hvdCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQgfHwge30pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtlbmRwb2ludE5hbWV9JHtyZXFDb3VudGVyfSR7cGF5bG9hZFNuYXBzaG90fWA7XG5cbiAgICBjb25zdCBkb1F1ZXJ5ID0gZGVib3VuY2UoNDAwLCBhc3luYyAoKSA9PiB7XG5cbiAgICAgIGxldCByZXNwOiBzdHJpbmc7XG4gICAgICBjb25zdCBjYWNoZWRSZXNwID0gY2FjaGVbY2FjaGVLZXldO1xuXG4gICAgICBpZiAoY2FjaGVkUmVzcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3AgPSBjYWNoZWRSZXNwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvL3VwZGF0ZVZhbHVlKGluaXRpYWxWYWx1ZSk7XG5cbiAgICAgICAgcmVzcCA9IGF3YWl0IGlwY0VuZHBvaW50UmVxdWVzdExvY2suYWNxdWlyZShlbmRwb2ludE5hbWUsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkVG9TZW5kID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCB8fCB7fSk7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGlwY1JlbmRlcmVyLmludm9rZShlbmRwb2ludE5hbWUsIHBheWxvYWRUb1NlbmQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSByZXNwO1xuICAgICAgICAvL30pKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3AsIHJldml2ZUpzb25WYWx1ZSk7XG5cbiAgICAgIGlmIChkYXRhLmVycm9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBkYXRhIGFzIElQQ1Jlc3BvbnNlPE8+O1xuXG4gICAgICAgIGlmIChyZXNwLnJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVwZGF0ZUVycm9ycyhyZXNwLmVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUVycm9ycyhbXCJVbmtub3duIGVycm9yXCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlVmFsdWUoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVWYWx1ZShkYXRhIGFzIE8pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9RdWVyeSgpO1xuICB9LCBbcmVxQ291bnRlciwgcGF5bG9hZFNuYXBzaG90XSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgcmVmcmVzaDogKCkgPT4gdXBkYXRlUmVxQ291bnRlcihjb3VudGVyID0+IHsgcmV0dXJuIGNvdW50ZXIgKz0gMSB9KSxcbiAgICBfcmVxQ291bnRlcjogcmVxQ291bnRlcixcbiAgfTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbElQQzxJIGV4dGVuZHMgb2JqZWN0LCBPPlxuKGVuZHBvaW50TmFtZTogc3RyaW5nLCBwYXlsb2FkPzogSSk6IFByb21pc2U8Tz4ge1xuICByZXR1cm4gaXBjRW5kcG9pbnRSZXF1ZXN0TG9jay5hY3F1aXJlKGVuZHBvaW50TmFtZSwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJhd0RhdGEgPSBhd2FpdCBpcGNSZW5kZXJlci5pbnZva2UoZW5kcG9pbnROYW1lLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPE8+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhd0RhdGEsIHJldml2ZUpzb25WYWx1ZSk7XG4gICAgICBpZiAoZGF0YS5lcnJvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBNZWFucyBtYWluIGlzIHVzaW5nIGxpc3RlbigpLCBuZXcgQVBJXG4gICAgICAgIGNvbnN0IHJlc3A6IElQQ1Jlc3BvbnNlPE8+ID0gZGF0YTtcblxuICAgICAgICBpZiAocmVzcC5yZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXNwLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IElQQ0ZhaWx1cmUocmVzcC5lcnJvcnMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBJUENGYWlsdXJlKFtcIlVua25vd24gZXJyb3JcIl0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShkYXRhLnJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZWFucyBtYWluIGlzIHVzaW5nIG1ha2VFbmRwb2ludCgpLCBsZWdhY3kgQVBJXG4gICAgICAgIGNvbnN0IHJlc3VsdDogTyA9IGRhdGE7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbGF5SVBDRXZlbnRcbjxcbiAgSSBleHRlbmRzIG9iamVjdCA9IHsgZXZlbnROYW1lOiBzdHJpbmcsIGV2ZW50UGF5bG9hZD86IGFueSB9LFxuICBPID0geyBzdWNjZXNzOiB0cnVlIH0sXG4+XG4ocGF5bG9hZDogSSk6IFByb21pc2U8Tz4ge1xuICByZXR1cm4gYXdhaXQgY2FsbElQQzxJLCBPPigncmVsYXktZXZlbnQtdG8tYWxsLXdpbmRvd3MnLCBwYXlsb2FkKTtcbn1cblxuXG5pbnRlcmZhY2UgSVBDSG9vazxUPiB7XG4gIHZhbHVlOiBULFxuICBlcnJvcnM6IHN0cmluZ1tdLFxuICByZWZyZXNoOiAoKSA9PiB2b2lkLFxuICBfcmVxQ291bnRlcjogbnVtYmVyLFxufVxuXG5cbmNvbnN0IGlwY0VuZHBvaW50UmVxdWVzdExvY2sgPSBuZXcgQXN5bmNMb2NrKHsgbWF4UGVuZGluZzogMTAwMDAwIH0pOyJdfQ==