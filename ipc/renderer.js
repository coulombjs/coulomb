/* Wraps IPC communication in React hooks & locking queue. */
import AsyncLock from 'async-lock';
import * as log from 'electron-log';
import { ipcRenderer } from 'electron';
import { useEffect, useState } from 'react';
import { reviveJsonValue } from './utils';
var cache = {};
class IPCFailure extends Error {
    constructor(errorMessageList) {
        super(errorMessageList.join('; '));
        this.errorMessageList = errorMessageList;
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
export function useIPCEvent(endpointName, handler) {
    /* Sets up main -> renderer event listener & cleanup on component destruction. */
    useEffect(() => {
        function handleEvent(evt, payload) {
            log.debug("Handling IPC event", endpointName);
            handler(payload);
        }
        ipcRenderer.on(endpointName, handleEvent);
        return function cleanup() {
            ipcRenderer.removeListener(endpointName, handleEvent);
        };
    }, []);
}
export function useIPCValue(endpointName, initialValue, payload) {
    /* Invokes an endpoint and provides result state in the form of a hook.
       State can be updated by calling `refresh()`. */
    const [value, updateValue] = useState(initialValue);
    const [errors, updateErrors] = useState([]);
    const [isUpdating, setUpdating] = useState(false);
    const [reqCounter, updateReqCounter] = useState(0);
    const payloadSnapshot = JSON.stringify(payload || {});
    useEffect(() => {
        setUpdating(false);
    }, [value]);
    useEffect(() => {
        setUpdating(true);
        const cacheKey = `${endpointName}${reqCounter}${payloadSnapshot}`;
        const doQuery = async () => {
            let resp;
            const cachedResp = cache[cacheKey];
            if (cachedResp !== undefined) {
                resp = cachedResp;
            }
            else {
                //(async () => {
                //updateValue(initialValue);
                resp = await ipcEndpointRequestLock.acquire(endpointName, async function () {
                    const payloadToSend = JSON.stringify(payload || {});
                    return await ipcRenderer.invoke(endpointName, payloadToSend);
                });
                cache[cacheKey] = resp;
                //})();
            }
            const data = JSON.parse(resp, reviveJsonValue);
            if (data.errors !== undefined) {
                const resp = data;
                if (resp.result === undefined) {
                    if (resp.errors.length > 0) {
                        updateErrors(resp.errors);
                    }
                    else {
                        updateErrors(["Unknown error"]);
                    }
                    updateValue(initialValue);
                }
                else {
                    updateValue(data.result);
                }
            }
            else {
                updateValue(data);
            }
        };
        doQuery();
    }, [reqCounter, payloadSnapshot]);
    return {
        value: value,
        errors: errors,
        isUpdating: isUpdating,
        refresh: () => updateReqCounter(counter => { return counter += 1; }),
        _reqCounter: reqCounter,
    };
}
export async function callIPC(endpointName, payload) {
    return ipcEndpointRequestLock.acquire(endpointName, async function () {
        const rawData = await ipcRenderer.invoke(endpointName, JSON.stringify(payload));
        return new Promise((resolve, reject) => {
            const data = JSON.parse(rawData, reviveJsonValue);
            if (data.errors !== undefined) {
                // Means main is using listen(), new API
                const resp = data;
                if (resp.result === undefined) {
                    if (resp.errors.length > 0) {
                        reject(new IPCFailure(resp.errors));
                    }
                    else {
                        reject(new IPCFailure(["Unknown error"]));
                    }
                }
                resolve(data.result);
            }
            else {
                // Means main is using makeEndpoint(), legacy API
                const result = data;
                resolve(result);
            }
        });
    });
}
export async function relayIPCEvent(payload) {
    return await callIPC('relay-event-to-all-windows', payload);
}
const ipcEndpointRequestLock = new AsyncLock({ maxPending: 100000 });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaXBjL3JlbmRlcmVyLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7QUFFN0QsT0FBTyxTQUFTLE1BQU0sWUFBWSxDQUFDO0FBQ25DLE9BQU8sS0FBSyxHQUFHLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFFNUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUcxQyxJQUFJLEtBQUssR0FBMEIsRUFBRSxDQUFDO0FBU3RDLE1BQU0sVUFBVyxTQUFRLEtBQUs7SUFDNUIsWUFBbUIsZ0JBQTBCO1FBQzNDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQURsQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQVU7UUFFM0MsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRCxDQUFDO0NBQ0Y7QUFHRCxNQUFNLFVBQVUsV0FBVyxDQUMxQixZQUFvQixFQUFFLE9BQTZCO0lBQ2xELGlGQUFpRjtJQUVqRixTQUFTLENBQUMsR0FBRyxFQUFFO1FBQ2IsU0FBUyxXQUFXLENBQUMsR0FBbUIsRUFBRSxPQUFVO1lBQ2xELEdBQUcsQ0FBQyxLQUFLLENBQUMsb0JBQW9CLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDOUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25CLENBQUM7UUFDRCxXQUFXLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztRQUMxQyxPQUFPLFNBQVMsT0FBTztZQUNyQixXQUFXLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxX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QUFDO2FBQ2pCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFHRCxNQUFNLENBQUMsS0FBSyxVQUFVLGFBQWEsQ0FLbEMsT0FBVTtJQUNULE9BQU8sTUFBTSxPQUFPLENBQU8sNEJBQTRCLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDcEUsQ0FBQztBQVlELE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxTQUFTLENBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFdyYXBzIElQQyBjb21tdW5pY2F0aW9uIGluIFJlYWN0IGhvb2tzICYgbG9ja2luZyBxdWV1ZS4gKi9cblxuaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICdlbGVjdHJvbi1sb2cnO1xuaW1wb3J0IHsgaXBjUmVuZGVyZXIgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyByZXZpdmVKc29uVmFsdWUgfSBmcm9tICcuL3V0aWxzJztcblxuXG52YXIgY2FjaGU6IHsgW2lkOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG5cbnR5cGUgSVBDUmVzcG9uc2U8Tz4gPSB7XG4gIGVycm9yczogc3RyaW5nW11cbiAgcmVzdWx0OiBPIHwgdW5kZWZpbmVkXG59O1xuXG5cbmNsYXNzIElQQ0ZhaWx1cmUgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlcnJvck1lc3NhZ2VMaXN0OiBzdHJpbmdbXSkge1xuICAgIHN1cGVyKGVycm9yTWVzc2FnZUxpc3Quam9pbignOyAnKSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJUENFdmVudDxQIGV4dGVuZHMgb2JqZWN0PlxuKGVuZHBvaW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiAocGF5bG9hZDogUCkgPT4gdm9pZCkge1xuICAvKiBTZXRzIHVwIG1haW4gLT4gcmVuZGVyZXIgZXZlbnQgbGlzdGVuZXIgJiBjbGVhbnVwIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gKi9cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2dDogRWxlY3Ryb24uRXZlbnQsIHBheWxvYWQ6IFApIHtcbiAgICAgIGxvZy5kZWJ1ZyhcIkhhbmRsaW5nIElQQyBldmVudFwiLCBlbmRwb2ludE5hbWUpO1xuICAgICAgaGFuZGxlcihwYXlsb2FkKTtcbiAgICB9XG4gICAgaXBjUmVuZGVyZXIub24oZW5kcG9pbnROYW1lLCBoYW5kbGVFdmVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBpcGNSZW5kZXJlci5yZW1vdmVMaXN0ZW5lcihlbmRwb2ludE5hbWUsIGhhbmRsZUV2ZW50KTtcbiAgICB9XG4gIH0sIFtdKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSVBDVmFsdWU8SSBleHRlbmRzIG9iamVjdCwgTz5cbihlbmRwb2ludE5hbWU6IHN0cmluZywgaW5pdGlhbFZhbHVlOiBPLCBwYXlsb2FkPzogSSk6IElQQ0hvb2s8Tz4ge1xuICAvKiBJbnZva2VzIGFuIGVuZHBvaW50IGFuZCBwcm92aWRlcyByZXN1bHQgc3RhdGUgaW4gdGhlIGZvcm0gb2YgYSBob29rLlxuICAgICBTdGF0ZSBjYW4gYmUgdXBkYXRlZCBieSBjYWxsaW5nIGByZWZyZXNoKClgLiAqL1xuXG4gIGNvbnN0IFt2YWx1ZSwgdXBkYXRlVmFsdWVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgW2Vycm9ycywgdXBkYXRlRXJyb3JzXSA9IHVzZVN0YXRlKFtdIGFzIHN0cmluZ1tdKTtcbiAgY29uc3QgW2lzVXBkYXRpbmcsIHNldFVwZGF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBbcmVxQ291bnRlciwgdXBkYXRlUmVxQ291bnRlcl0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgcGF5bG9hZFNuYXBzaG90ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCB8fCB7fSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRVcGRhdGluZyhmYWxzZSk7XG4gIH0sIFt2YWx1ZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0VXBkYXRpbmcodHJ1ZSk7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGAke2VuZHBvaW50TmFtZX0ke3JlcUNvdW50ZXJ9JHtwYXlsb2FkU25hcHNob3R9YDtcblxuICAgIGNvbnN0IGRvUXVlcnkgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVzcDogc3RyaW5nO1xuICAgICAgY29uc3QgY2FjaGVkUmVzcCA9IGNhY2hlW2NhY2hlS2V5XTtcblxuICAgICAgaWYgKGNhY2hlZFJlc3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXNwID0gY2FjaGVkUmVzcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy91cGRhdGVWYWx1ZShpbml0aWFsVmFsdWUpO1xuXG4gICAgICAgIHJlc3AgPSBhd2FpdCBpcGNFbmRwb2ludFJlcXVlc3RMb2NrLmFjcXVpcmUoZW5kcG9pbnROYW1lLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZFRvU2VuZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQgfHwge30pO1xuICAgICAgICAgIHJldHVybiBhd2FpdCBpcGNSZW5kZXJlci5pbnZva2UoZW5kcG9pbnROYW1lLCBwYXlsb2FkVG9TZW5kKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0gcmVzcDtcbiAgICAgICAgLy99KSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyZXNwLCByZXZpdmVKc29uVmFsdWUpO1xuXG4gICAgICBpZiAoZGF0YS5lcnJvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCByZXNwID0gZGF0YSBhcyBJUENSZXNwb25zZTxPPjtcblxuICAgICAgICBpZiAocmVzcC5yZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXNwLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVFcnJvcnMocmVzcC5lcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVFcnJvcnMoW1wiVW5rbm93biBlcnJvclwiXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlVmFsdWUoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVWYWx1ZShkYXRhIGFzIE8pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb1F1ZXJ5KCk7XG4gIH0sIFtyZXFDb3VudGVyLCBwYXlsb2FkU25hcHNob3RdKTtcblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBlcnJvcnM6IGVycm9ycyxcbiAgICBpc1VwZGF0aW5nOiBpc1VwZGF0aW5nLFxuICAgIHJlZnJlc2g6ICgpID0+IHVwZGF0ZVJlcUNvdW50ZXIoY291bnRlciA9PiB7IHJldHVybiBjb3VudGVyICs9IDEgfSksXG4gICAgX3JlcUNvdW50ZXI6IHJlcUNvdW50ZXIsXG4gIH07XG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxJUEM8SSBleHRlbmRzIG9iamVjdCwgTz5cbihlbmRwb2ludE5hbWU6IHN0cmluZywgcGF5bG9hZD86IEkpOiBQcm9taXNlPE8+IHtcbiAgcmV0dXJuIGlwY0VuZHBvaW50UmVxdWVzdExvY2suYWNxdWlyZShlbmRwb2ludE5hbWUsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByYXdEYXRhID0gYXdhaXQgaXBjUmVuZGVyZXIuaW52b2tlKGVuZHBvaW50TmFtZSwgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxPPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXdEYXRhLCByZXZpdmVKc29uVmFsdWUpO1xuICAgICAgaWYgKGRhdGEuZXJyb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTWVhbnMgbWFpbiBpcyB1c2luZyBsaXN0ZW4oKSwgbmV3IEFQSVxuICAgICAgICBjb25zdCByZXNwOiBJUENSZXNwb25zZTxPPiA9IGRhdGE7XG5cbiAgICAgICAgaWYgKHJlc3AucmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzcC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBJUENGYWlsdXJlKHJlc3AuZXJyb3JzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgSVBDRmFpbHVyZShbXCJVbmtub3duIGVycm9yXCJdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZGF0YS5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWVhbnMgbWFpbiBpcyB1c2luZyBtYWtlRW5kcG9pbnQoKSwgbGVnYWN5IEFQSVxuICAgICAgICBjb25zdCByZXN1bHQ6IE8gPSBkYXRhO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWxheUlQQ0V2ZW50XG48XG4gIEkgZXh0ZW5kcyBvYmplY3QgPSB7IGV2ZW50TmFtZTogc3RyaW5nLCBldmVudFBheWxvYWQ/OiBhbnkgfSxcbiAgTyA9IHsgc3VjY2VzczogdHJ1ZSB9LFxuPlxuKHBheWxvYWQ6IEkpOiBQcm9taXNlPE8+IHtcbiAgcmV0dXJuIGF3YWl0IGNhbGxJUEM8SSwgTz4oJ3JlbGF5LWV2ZW50LXRvLWFsbC13aW5kb3dzJywgcGF5bG9hZCk7XG59XG5cblxuaW50ZXJmYWNlIElQQ0hvb2s8VD4ge1xuICB2YWx1ZTogVFxuICBlcnJvcnM6IHN0cmluZ1tdXG4gIGlzVXBkYXRpbmc6IGJvb2xlYW5cbiAgcmVmcmVzaDogKCkgPT4gdm9pZFxuICBfcmVxQ291bnRlcjogbnVtYmVyXG59XG5cblxuY29uc3QgaXBjRW5kcG9pbnRSZXF1ZXN0TG9jayA9IG5ldyBBc3luY0xvY2soeyBtYXhQZW5kaW5nOiAxMDAwMDAgfSk7Il19